solution <- initial_solution(target)
steps <- ceiling(log(x = 0.00001, base = alpha)) * iterations # number of steps
tick <- 0
old_cost <- cost(target = target, solution = solution)
initial_solution(target)
target <- default_names(rbm(10,10))
initial_solution <- function(M){
# generates an empty matrix with same dimensions as M.
matrix(0, nrow = nrow(M), ncol = ncol(M))
}
solution <- default_names(initial_solution(target))
solution
steps <- ceiling(log(x = 0.00001, base = alpha)) * iterations # number of steps
tick <- 0
old_cost <- cost(target = target, solution = solution)
cost(target = target, solution = solution)
cost(target = target, solution = solution)
highest_nestedness <- old_cost
highest_nestedness_mat <- solution
Temp <- initial_temp
Temp_min <- 0.00001
neighbour(solution)
neighbour(solution)
new_solution <- neighbour(solution)
cost(target = target, solution = new_solution)
highest_nestedness
acceptance_probability(old_cost = old_cost, new_cost = new_cost, Temp = Temp)
old_cost
new_cost
Temp
# R version 3.4.3 (2017-11-30)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Sierra 10.12
#
# Matrix products: default
# BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
# LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib
#
# locale:
#   [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8
#
# attached base packages:
#   [1] stats     graphics  grDevices utils     datasets  methods   base
#
# loaded via a namespace (and not attached):
#   [1] colorspace_1.4-0 scales_0.5.0     compiler_3.4.3   lazyeval_0.2.0   plyr_1.8.4       tools_3.4.3      gtable_0.2.0     tibble_1.3.3     Rcpp_0.12.13     ggplot2_2.2.1    grid_3.4.3       rlang_0.1.4      munsell_0.4.3
# this script is a simulated annealing algorithm for generating a network from a collection of species roles
rm(list = ls())
# load packages
library(bmotif)
library(nettools)
m <- rbm(2,2)
m <- default_names(m)
positions(m, six_node = FALSE, level = "all", normalisation = "none")
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
# target <- c(as.matrix(positions(mt, six_node = FALSE, level = "all", normalisation = "none")))
# solution <- c(as.matrix(positions(ms, six_node = FALSE, level = "all", normalisation = "none")))
mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
neighbour <- function(M){
# generates a neighbour solution by either adding a link, removing a link or moving a link
full <- all(M == 1)
empty <- all(M == 0)
if(empty == TRUE){
mutation <- 1 # if matrix is empty, have to add a link
} else if(full == TRUE){
mutation <- 2 # if matrix is full, have to remove a link
} else {
mutation <- sample.int(3)[1] # if neither full nor empty, any mutation will do
}
if(mutation == 1){ # adds a link
to_add <- which(M == 0, arr.ind = TRUE) # coordinates of 0s
wc <- sample.int(nrow(to_add), 1) # pick a row from list of 0 coordinates
cr <- to_add[wc,"row"] # extract the chosen row
cc <- to_add[wc,"col"]# extract the chosen column
M[cr,cc] <- 1 # add a link
} else if(mutation == 2){ # removes a link
to_remove <- which(M != 0, arr.ind = TRUE) # coordinates of 1s
wc <- sample.int(nrow(to_remove), 1) # pick a row from list of 1 coordinates
cr <- to_remove[wc,"row"] # extract the chosen row
cc <- to_remove[wc,"col"] # extract the chosen column
M[cr,cc] <- 0 # remove the link
} else if(mutation == 3){ # moves one link e.g. i-j -> m-n
to_remove <- which(M != 0, arr.ind = TRUE) # coordinates of 1s
to_add <- which(M == 0, arr.ind = TRUE) # coordinates of 0s
wc <- sample.int(nrow(to_remove), 1) # pick a row from list of 1 coordinates
cr <- to_remove[wc,"row"] # extract the chosen row
cc <- to_remove[wc,"col"] # extract the chosen column
M[cr,cc] <- 0 # remove the link
wc <- sample.int(nrow(to_add), 1) # pick a row from list of 0 coordinates
cr <- to_add[wc,"row"] # extract the chosen row
cc <- to_add[wc,"col"]# extract the chosen column
M[cr,cc] <- 1 # add a link
}
M # return the matrix
}
initial_solution <- function(M){
# generates an empty matrix with same dimensions as M.
matrix(0, nrow = nrow(M), ncol = ncol(M))
}
cost <- function(target, solution){
target_vector <- c(as.matrix(positions(target, six_node = FALSE, level = "all", normalisation = "none")))
solution_vector <- c(as.matrix(positions(solution, six_node = FALSE, level = "all", normalisation = "none")))
dm <- rbind(target_vector, solution_vector) # data matrix
vegdist(dm, method = "bray")[1]
}
acceptance_probability <- function(old_cost, new_cost, Temp){
exp((old_cost - new_cost)/Temp)
}
mm <- function(target, solution, alpha, iterations, initial_temp){ # motif match
steps <- ceiling(log(x = 0.00001, base = alpha)) * iterations # number of steps
tick <- 0
old_cost <- cost(target = target, solution = solution)
highest_nestedness <- old_cost
highest_nestedness_mat <- solution
Temp <- initial_temp
Temp_min <- 0.00001
pb <- txtProgressBar(min = 0, max = steps, initial = 0, style = 3)
while(Temp > Temp_min){
i <- 1
while(i <= iterations){
tick <- tick + 1
setTxtProgressBar(pb, tick)
new_solution <- neighbour(solution)
new_cost <- cost(target = target, solution = new_solution)
# record
if(((new_cost) < highest_nestedness)){
highest_nestedness <- new_cost
highest_nestedness_mat <- new_solution
}
ap <- acceptance_probability(old_cost = old_cost, new_cost = new_cost, Temp = Temp)
if(ap > runif(1,0,1)){
solution <- new_solution
old_cost <- new_cost
}
i <- i + 1
}
Temp <- Temp * alpha
# print(x = paste0("Temperature = ", round(Temp, digits = 7), " /// Nestedness = ", round(1-old_cost, digits = 6)))
}
# return(list(final_mat = solution, final_nest = 1-old_cost, steps = steps, solutions = solutions))
return(list(final_mat = solution, final_nest = old_cost, highest_nestedness = highest_nestedness, highest_nestedness_mat = highest_nestedness_mat))
}
mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
warnings()
# R version 3.4.3 (2017-11-30)
# Platform: x86_64-apple-darwin15.6.0 (64-bit)
# Running under: macOS Sierra 10.12
#
# Matrix products: default
# BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib
# LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib
#
# locale:
#   [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8
#
# attached base packages:
#   [1] stats     graphics  grDevices utils     datasets  methods   base
#
# loaded via a namespace (and not attached):
#   [1] colorspace_1.4-0 scales_0.5.0     compiler_3.4.3   lazyeval_0.2.0   plyr_1.8.4       tools_3.4.3      gtable_0.2.0     tibble_1.3.3     Rcpp_0.12.13     ggplot2_2.2.1    grid_3.4.3       rlang_0.1.4      munsell_0.4.3
# this script is a simulated annealing algorithm for generating a network from a collection of species roles
rm(list = ls())
# load packages
library(bmotif)
library(nettools)
m <- rbm(2,2)
m <- default_names(m)
positions(m, six_node = FALSE, level = "all", normalisation = "none")
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
# target <- c(as.matrix(positions(mt, six_node = FALSE, level = "all", normalisation = "none")))
# solution <- c(as.matrix(positions(ms, six_node = FALSE, level = "all", normalisation = "none")))
mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
neighbour <- function(M){
# generates a neighbour solution by either adding a link, removing a link or moving a link
full <- all(M == 1)
empty <- all(M == 0)
if(empty == TRUE){
mutation <- 1 # if matrix is empty, have to add a link
} else if(full == TRUE){
mutation <- 2 # if matrix is full, have to remove a link
} else {
mutation <- sample.int(3)[1] # if neither full nor empty, any mutation will do
}
if(mutation == 1){ # adds a link
to_add <- which(M == 0, arr.ind = TRUE) # coordinates of 0s
wc <- sample.int(nrow(to_add), 1) # pick a row from list of 0 coordinates
cr <- to_add[wc,"row"] # extract the chosen row
cc <- to_add[wc,"col"]# extract the chosen column
M[cr,cc] <- 1 # add a link
} else if(mutation == 2){ # removes a link
to_remove <- which(M != 0, arr.ind = TRUE) # coordinates of 1s
wc <- sample.int(nrow(to_remove), 1) # pick a row from list of 1 coordinates
cr <- to_remove[wc,"row"] # extract the chosen row
cc <- to_remove[wc,"col"] # extract the chosen column
M[cr,cc] <- 0 # remove the link
} else if(mutation == 3){ # moves one link e.g. i-j -> m-n
to_remove <- which(M != 0, arr.ind = TRUE) # coordinates of 1s
to_add <- which(M == 0, arr.ind = TRUE) # coordinates of 0s
wc <- sample.int(nrow(to_remove), 1) # pick a row from list of 1 coordinates
cr <- to_remove[wc,"row"] # extract the chosen row
cc <- to_remove[wc,"col"] # extract the chosen column
M[cr,cc] <- 0 # remove the link
wc <- sample.int(nrow(to_add), 1) # pick a row from list of 0 coordinates
cr <- to_add[wc,"row"] # extract the chosen row
cc <- to_add[wc,"col"]# extract the chosen column
M[cr,cc] <- 1 # add a link
}
M # return the matrix
}
initial_solution <- function(M){
# generates an empty matrix with same dimensions as M.
matrix(0, nrow = nrow(M), ncol = ncol(M))
}
cost <- function(target, solution){
target_vector <- c(as.matrix(positions(target, six_node = FALSE, level = "all", normalisation = "none")))
solution_vector <- c(as.matrix(positions(solution, six_node = FALSE, level = "all", normalisation = "none")))
dm <- rbind(target_vector, solution_vector) # data matrix
vegdist(dm, method = "bray")[1]
}
acceptance_probability <- function(old_cost, new_cost, Temp){
exp((old_cost - new_cost)/Temp)
}
mm <- function(target, solution, alpha, iterations, initial_temp){ # motif match
steps <- ceiling(log(x = 0.00001, base = alpha)) * iterations # number of steps
tick <- 0
old_cost <- cost(target = target, solution = solution)
highest_nestedness <- old_cost
highest_nestedness_mat <- solution
Temp <- initial_temp
Temp_min <- 0.00001
pb <- txtProgressBar(min = 0, max = steps, initial = 0, style = 3)
while(Temp > Temp_min){
i <- 1
while(i <= iterations){
tick <- tick + 1
setTxtProgressBar(pb, tick)
new_solution <- neighbour(solution)
new_cost <- cost(target = target, solution = new_solution)
# record
if(((new_cost) < highest_nestedness)){
highest_nestedness <- new_cost
highest_nestedness_mat <- new_solution
}
ap <- acceptance_probability(old_cost = old_cost, new_cost = new_cost, Temp = Temp)
if(ap > runif(1,0,1)){
solution <- new_solution
old_cost <- new_cost
}
i <- i + 1
}
Temp <- Temp * alpha
# print(x = paste0("Temperature = ", round(Temp, digits = 7), " /// Nestedness = ", round(1-old_cost, digits = 6)))
}
# return(list(final_mat = solution, final_nest = 1-old_cost, steps = steps, solutions = solutions))
return(list(final_mat = solution, final_cost = old_cost, lowest_cost = highest_nestedness, highest_nestedness_mat = highest_nestedness_mat))
}
mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
rm(list = ls())
library(bmotif)
library(nettools)
m <- rbm(2,2)
m <- default_names(m)
positions(m, six_node = FALSE, level = "all", normalisation = "none")
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
test <- mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
neighbour <- function(M){
# generates a neighbour solution by either adding a link, removing a link or moving a link
full <- all(M == 1)
empty <- all(M == 0)
if(empty == TRUE){
mutation <- 1 # if matrix is empty, have to add a link
} else if(full == TRUE){
mutation <- 2 # if matrix is full, have to remove a link
} else {
mutation <- sample.int(3)[1] # if neither full nor empty, any mutation will do
}
if(mutation == 1){ # adds a link
to_add <- which(M == 0, arr.ind = TRUE) # coordinates of 0s
wc <- sample.int(nrow(to_add), 1) # pick a row from list of 0 coordinates
cr <- to_add[wc,"row"] # extract the chosen row
cc <- to_add[wc,"col"]# extract the chosen column
M[cr,cc] <- 1 # add a link
} else if(mutation == 2){ # removes a link
to_remove <- which(M != 0, arr.ind = TRUE) # coordinates of 1s
wc <- sample.int(nrow(to_remove), 1) # pick a row from list of 1 coordinates
cr <- to_remove[wc,"row"] # extract the chosen row
cc <- to_remove[wc,"col"] # extract the chosen column
M[cr,cc] <- 0 # remove the link
} else if(mutation == 3){ # moves one link e.g. i-j -> m-n
to_remove <- which(M != 0, arr.ind = TRUE) # coordinates of 1s
to_add <- which(M == 0, arr.ind = TRUE) # coordinates of 0s
wc <- sample.int(nrow(to_remove), 1) # pick a row from list of 1 coordinates
cr <- to_remove[wc,"row"] # extract the chosen row
cc <- to_remove[wc,"col"] # extract the chosen column
M[cr,cc] <- 0 # remove the link
wc <- sample.int(nrow(to_add), 1) # pick a row from list of 0 coordinates
cr <- to_add[wc,"row"] # extract the chosen row
cc <- to_add[wc,"col"]# extract the chosen column
M[cr,cc] <- 1 # add a link
}
M # return the matrix
}
initial_solution <- function(M){
# generates an empty matrix with same dimensions as M.
matrix(0, nrow = nrow(M), ncol = ncol(M))
}
cost <- function(target, solution){
target_vector <- c(as.matrix(positions(target, six_node = FALSE, level = "all", normalisation = "none")))
solution_vector <- c(as.matrix(positions(solution, six_node = FALSE, level = "all", normalisation = "none")))
dm <- rbind(target_vector, solution_vector) # data matrix
vegdist(dm, method = "bray")[1]
}
acceptance_probability <- function(old_cost, new_cost, Temp){
exp((old_cost - new_cost)/Temp)
}
mm <- function(target, solution, alpha, iterations, initial_temp){ # motif match
steps <- ceiling(log(x = 0.00001, base = alpha)) * iterations # number of steps
tick <- 0
old_cost <- cost(target = target, solution = solution)
highest_nestedness <- old_cost
highest_nestedness_mat <- solution
Temp <- initial_temp
Temp_min <- 0.00001
pb <- txtProgressBar(min = 0, max = steps, initial = 0, style = 3)
while(Temp > Temp_min){
i <- 1
while(i <= iterations){
tick <- tick + 1
setTxtProgressBar(pb, tick)
new_solution <- neighbour(solution)
new_cost <- cost(target = target, solution = new_solution)
# record
if(((new_cost) < highest_nestedness)){
highest_nestedness <- new_cost
highest_nestedness_mat <- new_solution
}
ap <- acceptance_probability(old_cost = old_cost, new_cost = new_cost, Temp = Temp)
if(ap > runif(1,0,1)){
solution <- new_solution
old_cost <- new_cost
}
i <- i + 1
}
Temp <- Temp * alpha
# print(x = paste0("Temperature = ", round(Temp, digits = 7), " /// Nestedness = ", round(1-old_cost, digits = 6)))
}
# return(list(final_mat = solution, final_nest = 1-old_cost, steps = steps, solutions = solutions))
return(list(final_mat = solution, final_cost = old_cost, lowest_cost = highest_nestedness, highest_nestedness_mat = highest_nestedness_mat))
}
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
test <- mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
target
solution
test
target_vector <- c(as.matrix(positions(target, six_node = FALSE, level = "all", normalisation = "none")))
solution_vector <- c(as.matrix(positions(test$highest_nestedness_mat, six_node = FALSE, level = "all", normalisation = "none")))
dm <- rbind(target_vector, solution_vector) # data matrix
dm
plot(target_vector, solution_vector)
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
target_vector <- c(as.matrix(positions(target, six_node = FALSE, level = "all", normalisation = "none")))
solution_vector <- c(as.matrix(positions(test$highest_nestedness_mat, six_node = FALSE, level = "all", normalisation = "none")))
plot(target_vector, solution_vector)
solution_vector <- c(as.matrix(positions(solution, six_node = FALSE, level = "all", normalisation = "none")))
plot(target_vector, solution_vector)
target <- default_names(rbm(10,10))
solution <- default_names(initial_solution(target))
test <- mm(target = target, solution = solution, alpha = 0.9, iterations = 10, initial_temp = 1)
target_vector <- c(as.matrix(positions(target, six_node = FALSE, level = "all", normalisation = "none")))
solution_vector <- c(as.matrix(positions(test$highest_nestedness_mat, six_node = FALSE, level = "all", normalisation = "none")))
plot(target_vector, solution_vector)
default_names(rbm(10,10))
target <- default_names(rbm(10,10))
positions(target, six_node = FALSE, level = "all", normalisation = "none")
mat <- default_names(rbm(10,10))
target <- positions(target, six_node = FALSE, level = "all", normalisation = "none")
target
c(as.matrix(target))
setwd("/Users/bennosimmons/Dropbox/Documents/Education/Cambridge_PhD/Bo_caribbean_webs/code_release/")
rm(list = ls())
library(bipartite)
source("IterNodeDelMultiSim.R")
web.store <- list()
files <- list.files("/data/webs/", full.names = FALSE)
for(i in 1:length(files)){
web <- t(empty(as.matrix(read.table(paste0("/data/webs/",files[i]), header = TRUE, row.names = 1))))
web.store[[gsub("\\.txt","",files[i])]] <- web
}
rvals <- read.csv("/data/rvalues.csv")
list.files("/data/webs/", full.names = FALSE)
getwd()
list.files()
list.files("./data/webs/", full.names = FALSE)
rm(list = ls())
library(bipartite)
source("IterNodeDelMultiSim.R")
web.store <- list()
files <- list.files("./data/webs/", full.names = FALSE)
for(i in 1:length(files)){
web <- t(empty(as.matrix(read.table(paste0("/data/webs/",files[i]), header = TRUE, row.names = 1))))
web.store[[gsub("\\.txt","",files[i])]] <- web
}
rvals <- read.csv("./data/rvalues.csv")
rvals$R <- trimws(rvals$R)
rm(list = ls())
library(bipartite)
source("IterNodeDelMultiSim.R")
web.store <- list()
files <- list.files("./data/webs/", full.names = FALSE)
for(i in 1:length(files)){
web <- t(empty(as.matrix(read.table(paste0("./data/webs/",files[i]), header = TRUE, row.names = 1))))
web.store[[gsub("\\.txt","",files[i])]] <- web
}
rvals <- read.csv("./data/rvalues.csv")
rvals$R <- trimws(rvals$R)
r_bounds <- as.data.frame(matrix(ncol = 3, nrow = length(unique(rvals$R)), dimnames = list(NULL,c("R","lb","ub"))))
r_bounds$R <- unique(rvals$R)
r_bounds[r_bounds$R == "low",][,c("lb","ub")] <- c(0,(1/3))
r_bounds[r_bounds$R == "high",][,c("lb","ub")] <- c((2/3),1)
r_bounds[r_bounds$R == "med-high",][,c("lb","ub")] <- c((1/3),1)
r_bounds[r_bounds$R == "low-med",][,c("lb","ub")] <- c(0,(2/3))
r_bounds[r_bounds$R == "med",][,c("lb","ub")] <- c((1/3),(2/3))
r_bounds[r_bounds$R == "low-high",][,c("lb","ub")] <- c(0,1)
rvals <- split(rvals, rvals$file_name)
rm(list = ls())
library(bipartite)
source("IterNodeDelMultiSim.R")
web.store <- list()
files <- list.files("./data/webs/", full.names = FALSE)
for(i in 1:length(files)){
web <- t(empty(as.matrix(read.table(paste0("./data/webs/",files[i]), header = TRUE, row.names = 1))))
web.store[[gsub("\\.txt","",files[i])]] <- web
}
rvals <- read.csv("./data/rvalues.csv")
rvals$R <- trimws(rvals$R)
r_bounds <- as.data.frame(matrix(ncol = 3, nrow = length(unique(rvals$R)), dimnames = list(NULL,c("R","lb","ub"))))
r_bounds$R <- unique(rvals$R)
r_bounds[r_bounds$R == "low",][,c("lb","ub")] <- c(0,(1/3))
r_bounds[r_bounds$R == "high",][,c("lb","ub")] <- c((2/3),1)
r_bounds[r_bounds$R == "med-high",][,c("lb","ub")] <- c((1/3),1)
r_bounds[r_bounds$R == "low-med",][,c("lb","ub")] <- c(0,(2/3))
r_bounds[r_bounds$R == "med",][,c("lb","ub")] <- c((1/3),(2/3))
r_bounds[r_bounds$R == "low-high",][,c("lb","ub")] <- c(0,1)
rvals <- split(rvals, rvals$file_name)
vulnerabilities <- NULL
for(i in 1:length(web.store)){
# run simulations
most <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "bo", removal.taxa = "plant", remove.order = "from most connected", nsim = 100)
strongest <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "bo", removal.taxa = "plant", remove.order = "from strongest", nsim = 100)
random <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "bo", removal.taxa = "plant", remove.order = "random", nsim = 100)
weakest <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "bo", removal.taxa = "plant", remove.order = "from weakest", nsim = 100)
least <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "bo", removal.taxa = "plant", remove.order = "from least connected", nsim = 100)
r.most <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "random", removal.taxa = "plant", remove.order = "from most connected", nsim = 100)
r.strongest <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "random", removal.taxa = "plant", remove.order = "from strongest", nsim = 100)
r.random <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "random", removal.taxa = "plant", remove.order = "random", nsim = 100)
r.weakest <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "random", removal.taxa = "plant", remove.order = "from weakest", nsim = 100)
r.least <- IterNodeDelMultiSim(network = web.store[[names(web.store[i])]], plant_r_assignments = rvals[[names(web.store[i])]], r_ints = r_bounds, bo_or_random = "random", removal.taxa = "plant", remove.order = "from least connected", nsim = 100)
# gather results
most <- merge(most$mean_order, most$mean_vulnerability, by = "species")
most$web <- names(web.store)[i]
most$removal.order <- "from most connected"
most$plantR <- "assigned"
strongest <- merge(strongest$mean_order, strongest$mean_vulnerability, by = "species")
strongest$web <- names(web.store)[i]
strongest$removal.order <- "from strongest"
strongest$plantR <- "assigned"
random <- merge(random$mean_order, random$mean_vulnerability, by = "species")
random$web <- names(web.store)[i]
random$removal.order <- "random"
random$plantR <- "assigned"
weakest <- merge(weakest$mean_order, weakest$mean_vulnerability, by = "species")
weakest$web <- names(web.store)[i]
weakest$removal.order <- "from weakest"
weakest$plantR <- "assigned"
least <- merge(least$mean_order, least$mean_vulnerability, by = "species")
least$web <- names(web.store)[i]
least$removal.order <- "from least connected"
least$plantR <- "assigned"
r.most <- merge(r.most$mean_order, r.most$mean_vulnerability, by = "species")
r.most$web <- names(web.store)[i]
r.most$removal.order <- "from most connected"
r.most$plantR <- "random"
r.strongest <- merge(r.strongest$mean_order, r.strongest$mean_vulnerability, by = "species")
r.strongest$web <- names(web.store)[i]
r.strongest$removal.order <- "from strongest"
r.strongest$plantR <- "random"
r.random <- merge(r.random$mean_order, r.random$mean_vulnerability, by = "species")
r.random$web <- names(web.store)[i]
r.random$removal.order <- "random"
r.random$plantR <- "random"
r.weakest <- merge(r.weakest$mean_order, r.weakest$mean_vulnerability, by = "species")
r.weakest$web <- names(web.store)[i]
r.weakest$removal.order <- "from weakest"
r.weakest$plantR <- "random"
r.least <- merge(r.least$mean_order, r.least$mean_vulnerability, by = "species")
r.least$web <- names(web.store)[i]
r.least$removal.order <- "from least connected"
r.least$plantR <- "random"
vulnerabilities <- rbind(vulnerabilities,rbind(most,strongest,random,weakest,least,r.most,r.strongest,r.random,r.weakest,r.least))
print(paste0(i,"/8"))
}
